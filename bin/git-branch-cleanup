#!/usr/bin/env bash

# Get default branch efficiently
DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
if [ -z "$DEFAULT_BRANCH" ]; then
  DEFAULT_BRANCH="main"
fi

# Get current branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

# Export environment variables for Python
export DEFAULT_BRANCH="$DEFAULT_BRANCH"
export CURRENT_BRANCH="$CURRENT_BRANCH"
export LINEAR_API_KEY="${LINEAR_API_KEY:-}"
export GIT_BRANCH_CLEANUP_DEBUG="${GIT_BRANCH_CLEANUP_DEBUG:-0}"

#

# Create temporary Python script
TEMP_SCRIPT=$(mktemp /tmp/git-branch-cleanup.XXXXXX.py)

# Write Python script to temp file
cat > "$TEMP_SCRIPT" << 'PYTHON_SCRIPT'
import subprocess
import sys
import os
import re
import json
from urllib.request import Request, urlopen
from urllib.error import URLError
from datetime import datetime

# Get environment variables
default_branch = os.environ.get("DEFAULT_BRANCH", "main")
current_branch = os.environ.get("CURRENT_BRANCH", "")
linear_api_key = os.environ.get("LINEAR_API_KEY", "")
debug_mode = os.environ.get("GIT_BRANCH_CLEANUP_DEBUG", "0") == "1"

# ANSI color codes
class Colors:
    CYAN = '\033[36m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    RED = '\033[31m'
    PURPLE = '\033[35m'
    GRAY = '\033[90m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    RESET = '\033[0m'
    STRIKE = '\033[9m'

def clear_screen():
    os.system('clear')

def get_linear_task_title(branch_name, api_key):
    """Fetch Linear task title for a branch."""
    if not api_key:
        return None

    # Extract Linear issue ID (format: ABC-123 or abc-123)
    patterns = [
        r'^([A-Z]{2,}-\d+)',  # At start: ABC-123
        r'/([A-Z]{2,}-\d+)',  # After slash: feature/ABC-123
        r'^([a-z]{2,}-\d+)',  # Lowercase at start
        r'/([a-z]{2,}-\d+)',  # Lowercase after slash
    ]

    issue_id = None
    for pattern in patterns:
        match = re.search(pattern, branch_name, re.IGNORECASE)
        if match:
            issue_id = match.group(1).upper()
            break

    if not issue_id:
        return None

    try:
        # Use the same query format as git-pr
        query = 'query GetIssue($issueId: String!) { issue(id: $issueId) { title identifier state { name } } }'

        data = {
            'query': query,
            'variables': {
                'issueId': issue_id
            }
        }

        req = Request('https://api.linear.app/graphql',
                     data=json.dumps(data).encode('utf-8'),
                     headers={
                         'Authorization': linear_api_key,
                         'Content-Type': 'application/json'
                     })

        response = urlopen(req, timeout=2)
        result = json.loads(response.read())

        issue = result.get('data', {}).get('issue')
        if issue:
            state = issue.get('state', {}).get('name', '')
            title = issue.get('title', '')
            if title:
                return {'title': title, 'state': state, 'id': issue_id}
    except Exception as e:
        if debug_mode:
            print(f'{Colors.RED}[DEBUG] Error fetching Linear task {issue_id}: {str(e)}{Colors.RESET}')

    return None

def get_branches():
    """Get all branches with their metadata."""
    branches = []

    # Get branches sorted by date (oldest first)
    result = subprocess.run(['git', 'for-each-ref', '--sort=committerdate', 'refs/heads',
                            '--format=%(refname:short)|%(committerdate:relative)|%(authorname)|%(committerdate:iso)'],
                           capture_output=True, text=True)

    for line in result.stdout.strip().split('\n'):
        if not line:
            continue
        parts = line.split('|')
        if len(parts) != 4:
            continue

        branch, last_commit, author, commit_date = parts

        # Skip default and current branches
        if branch == default_branch or branch == current_branch:
            continue

        # Get ahead/behind counts
        try:
            counts = subprocess.run(['git', 'rev-list', '--left-right', '--count', f'{default_branch}...{branch}'],
                                   capture_output=True, text=True)
            behind, ahead = counts.stdout.strip().split()
        except:
            behind, ahead = '0', '0'

        # Check if merged
        merged_check = subprocess.run(['git', 'branch', '--merged', default_branch],
                                     capture_output=True, text=True)
        is_merged = branch in merged_check.stdout

        # Fetch Linear task info
        linear_info = get_linear_task_title(branch, linear_api_key) if linear_api_key else None

        branches.append({
            'name': branch,
            'ahead': int(ahead),
            'behind': int(behind),
            'last_commit': last_commit,
            'author': author[:20],
            'is_merged': is_merged,
            'linear_info': linear_info,
            'deleted': False
        })

    return branches

def format_branch_name(branch, max_length=30):
    """Format branch name to fit in column."""
    if len(branch) > max_length:
        return branch[:max_length-3] + '...'
    return branch.ljust(max_length)

def format_linear_title(linear_info, max_length=40):
    """Format Linear title for display."""
    if not linear_info:
        return '-'.center(max_length)

    title = linear_info['title']
    state = linear_info['state']

    if state:
        display = f"{title} [{state}]"
    else:
        display = title

    if len(display) > max_length:
        return display[:max_length-3] + '...'
    return display.ljust(max_length)

def print_table(branches):
    """Print branches in a nice table format."""
    print(f"\n{Colors.BOLD}{Colors.CYAN}=== Git Branch Cleanup ==={Colors.RESET}")
    print(f"{Colors.GRAY}Current: {current_branch} | Default: {default_branch}{Colors.RESET}\n")

    # Header
    header = (
        f"{Colors.BOLD}ID   Branch                         "
        f"Linear Task                              "
        f"Status    Ahead/Behind  Last Commit      Author{Colors.RESET}"
    )
    print(header)
    print("─" * 120)

    for idx, branch in enumerate(branches, 1):
        # Skip if deleted
        if branch['deleted']:
            continue

        # ID
        id_str = f"{idx:2d}"

        # Branch name with color
        if branch['is_merged']:
            branch_color = Colors.GREEN
            status = f"{Colors.GREEN}Merged  {Colors.RESET}"
        else:
            branch_color = Colors.YELLOW
            status = f"{Colors.YELLOW}Unmerged{Colors.RESET}"

        branch_name = format_branch_name(branch['name'])

        # Linear info
        linear_display = format_linear_title(branch['linear_info'])
        if branch['linear_info']:
            linear_color = Colors.PURPLE
        else:
            linear_color = Colors.GRAY

        # Ahead/Behind
        ahead_behind = f"{branch['ahead']:3d}/{branch['behind']:3d}"

        # Format row
        row = (
            f"{Colors.BOLD}{id_str}{Colors.RESET}   "
            f"{branch_color}{branch_name}{Colors.RESET}  "
            f"{linear_color}{linear_display}{Colors.RESET}  "
            f"{status}  "
            f"{ahead_behind:12s}  "
            f"{Colors.GRAY}{branch['last_commit']:16s}  "
            f"{branch['author']}{Colors.RESET}"
        )

        print(row)

    print("─" * 120)

def delete_branch(branch_name):
    """Delete a git branch."""
    result = subprocess.run(['git', 'branch', '-D', branch_name],
                          capture_output=True, text=True)
    return result.returncode == 0

def main():
    # Get all branches
    branches = get_branches()

    if not branches:
        print(f"{Colors.YELLOW}No branches to clean up!{Colors.RESET}")
        return

    deleted_count = 0

    while True:
        clear_screen()

        # Print the table
        print_table(branches)

        # Show stats
        remaining = sum(1 for b in branches if not b['deleted'])
        print(f"\n{Colors.CYAN}Branches: {remaining} remaining, {deleted_count} deleted{Colors.RESET}")

        if remaining == 0:
            print(f"\n{Colors.GREEN}All branches cleaned up!{Colors.RESET}")
            break

        # Prompt for action
        print(f"\n{Colors.BOLD}Enter branch ID to delete, 'q' to quit, or press Enter to refresh:{Colors.RESET}")
        try:
            choice = input("> ").strip().lower()
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Cleanup cancelled.{Colors.RESET}")
            break
        except EOFError:
            # This can happen in some terminal environments
            print(f"\n{Colors.YELLOW}Cleanup cancelled.{Colors.RESET}")
            break

        if choice == 'q':
            break
        elif choice == '':
            continue  # Refresh

        # Try to parse as number
        try:
            branch_id = int(choice)
            if 1 <= branch_id <= len(branches):
                branch = branches[branch_id - 1]

                if branch['deleted']:
                    print(f"{Colors.RED}Branch already deleted!{Colors.RESET}")
                    input("Press Enter to continue...")
                    continue

                # Delete without confirmation
                if delete_branch(branch['name']):
                    branch['deleted'] = True
                    deleted_count += 1
                    print(f"{Colors.GREEN}✓ Deleted: {branch['name']}{Colors.RESET}")
                else:
                    print(f"{Colors.RED}✗ Failed to delete: {branch['name']}{Colors.RESET}")
                    input("Press Enter to continue...")
            else:
                print(f"{Colors.RED}Invalid ID. Please enter a number between 1 and {len(branches)}{Colors.RESET}")
                input("Press Enter to continue...")
        except ValueError:
            print(f"{Colors.RED}Invalid input. Please enter a number or 'q'{Colors.RESET}")
            input("Press Enter to continue...")

    # Final summary
    print(f"\n{Colors.BOLD}{Colors.CYAN}=== Cleanup Complete ==={Colors.RESET}")
    print(f"{Colors.GREEN}Deleted: {deleted_count} branches{Colors.RESET}")

    # Offer to prune remote branches
    print(f"\n{Colors.CYAN}Prune remote tracking branches? [y/N]:{Colors.RESET} ", end='')
    try:
        choice = input().strip().lower()
        if choice in ['y', 'yes']:
            subprocess.run(['git', 'remote', 'prune', 'origin'],
                          capture_output=True, text=True)
            print(f"{Colors.GREEN}✓ Pruned remote tracking branches{Colors.RESET}")
    except (EOFError, KeyboardInterrupt):
        pass

if __name__ == "__main__":
    main()

PYTHON_SCRIPT

# Run the Python script and cleanup
python3 "$TEMP_SCRIPT"
rm -f "$TEMP_SCRIPT"
